package server

import (
	"encoding/json"
	"fmt"
	"groupie-tracker/helper"
	"groupie-tracker/models"
	"html/template"
	"io"
	"net/http"
	"strconv"
	"strings"
)
type Artistlocation struct{
	Location models.Alllocation
	Artist []models.Artist
}

var ErrorMsgMap = map[int]Error{
	http.StatusBadRequest:          {http.StatusBadRequest, "Bad Request"},
	http.StatusNotFound:            {http.StatusNotFound, "Not Found"},
	http.StatusInternalServerError: {http.StatusInternalServerError, "Internal Server Error"},
	http.StatusMethodNotAllowed:    {http.StatusMethodNotAllowed, "Method Not Allowed"},
}

type Error struct {
	Code int
	Msg  string
}

func getArtists() ([]models.Artist, error) {
	response, err := http.Get("https://groupietrackers.herokuapp.com/api/artists")
	if err != nil {
		return nil, err
	}
	defer response.Body.Close()

	var artists []models.Artist

	err = json.NewDecoder(response.Body).Decode(&artists)
	if err != nil {
		return nil, err
	}

	return artists, nil
}

func getArtistById(id int, artist *models.Artist) error {

	url := fmt.Sprintf("https://groupietrackers.herokuapp.com/api/artists/%d", id)
	response, err := http.Get(url)
	if err != nil {
		return err
	}
	defer response.Body.Close()

	err = json.NewDecoder(response.Body).Decode(artist)
	if artist.Id == 0 {
		err = fmt.Errorf("no artist with this ID: %d", id)
	}

	if err != nil {
		return err
	}

	return err
}

func getLocations(url string, location *models.Location) error {
	response, err := http.Get(url)
	if err != nil {
		return err
	}
	defer response.Body.Close()

	err = json.NewDecoder(response.Body).Decode(location)
	if err != nil {
		return err
	}

	return err
}

func getDates(url string, date *models.Dates) error {
	response, err := http.Get(url)
	if err != nil {
		return err
	}
	defer response.Body.Close()

	err = json.NewDecoder(response.Body).Decode(date)
	if err != nil {
		return err
	}

	return err
}

func getRelations(url string, relations *models.Relations) error {
	response, err := http.Get(url)
	if err != nil {
		return err
	}
	defer response.Body.Close()

	body, _ := io.ReadAll(response.Body)

	err = json.Unmarshal(body, &relations)
	if err != nil {
		return err
	}

	return err
}
var artist, err := getArtists()
	 art ,err:=getAlllocation()

var artloc =Artistlocation{
	art ,
	artist,
	}

func IndexHandler(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path != "/" {
		RenderErrorPage(http.StatusNotFound, w)
		return
	}
	if r.Method != http.MethodGet {
		RenderErrorPage(http.StatusMethodNotAllowed, w)
		return
	}
	

	if err != nil {
		RenderErrorPage(http.StatusInternalServerError, w)
		return
	}
	s := "templates/index.html"
	tmpl, err := template.ParseFiles(s)

	if err != nil {
		RenderErrorPage(http.StatusInternalServerError, w)
		return
	}
	

	tmpl.Execute(w, artloc)
}

func ArtistHandler(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path != "/artist" {
		RenderErrorPage(http.StatusNotFound, w)
		return
	}
	if r.Method != http.MethodGet {
		RenderErrorPage(http.StatusMethodNotAllowed, w)
		return
	}
	s := "templates/artist.html"
	tmpl, err := template.ParseFiles(s)
	if err != nil {
		RenderErrorPage(http.StatusInternalServerError, w)
		return
	}

	idStr := r.URL.Query().Get("id")
	id, err := strconv.Atoi(idStr)

	if err != nil || id < 0 {
		RenderErrorPage(http.StatusBadRequest, w)
		return
	}
	var artist models.Artist

	err = getArtistById(id, &artist)

	if err != nil {
		RenderErrorPage(http.StatusNotFound, w)
		return
	}

	var artistRes models.ArtistResponse

	artistRes.Id = artist.Id
	artistRes.CreationDate = artist.CreationDate
	artistRes.FirstAlbum = helper.FormatDate(artist.FirstAlbum)
	artistRes.ImageURL = artist.Image
	artistRes.Members = artist.Members
	artistRes.Name = artist.Name

	getLocations(artist.Locations, &artistRes.Locations)

	// helper.FormatLocations(&artistRes.Locations)

	getDates(artistRes.Locations.DatesUrl, &artistRes.ConcertDates)

	artistRes.TotalConcerts = len(artistRes.ConcertDates.Dates)
	getRelations(artist.Relations, &artistRes.Relations)
	helper.FormatConcertDates(&artistRes.Relations)
	tmpl.Execute(w, artistRes)

}
func getAlllocation()(models.Alllocation ,error){

	var alllocations models.Alllocation
	rep ,err:= http.Get("https://groupietrackers.herokuapp.com/api/locations") 
	if err!= nil {
		return alllocations,err
	}
	err = json.NewDecoder(rep.Body).Decode(&alllocations)
	if err != nil {
		return alllocations, err
	}

	return alllocations, nil
}


func SearchHandler(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path != "/search" {
		RenderErrorPage(http.StatusNotFound, w)
		return
	}
	if r.Method != http.MethodGet {
		RenderErrorPage(http.StatusMethodNotAllowed, w)
		return
	}

	var sumbit =r.FormValue("search")
	sumbit=TrimSpaces(sumbit)
	var makhou  models.ArtistResponse
	if len(sumbit)==0{
		p := "templates/index.html"
		tmpl, err := template.ParseFiles(p)
		if err != nil {
			RenderErrorPage(http.StatusInternalServerError, w)
			return
		}
		tmpl.Execute(w,makhou)
		return

	
	}

	artists, err := getArtists()
	if err != nil {
		RenderErrorPage(http.StatusInternalServerError, w)
		return
	}

	var matchingArtists []models.Artist
	for _, a := range artists {
		if strings.Contains(strings.ToLower(a.Name), strings.ToLower(sumbit)) {
			matchingArtists = append(matchingArtists, a)
		}
	}

	

	for _, a := range artists {
		if strings.Contains(strconv.Itoa(a.CreationDate), sumbit) {
			matchingArtists = append(matchingArtists, a)
		}
	}

	for _, a := range artists {

		if strings.HasPrefix(strings.ToLower(a.FirstAlbum), strings.ToLower(sumbit)) {
			matchingArtists = append(matchingArtists, a)
		}
	}
	for _, a := range artists {
		for _, member := range a.Members {
		if strings.HasPrefix(strings.ToLower(member), strings.ToLower(sumbit)) {
			matchingArtists = append(matchingArtists, a)
		}
	}
	

	}
	alllocations,_ := getAlllocation()
	for _, location:= range alllocations.Index{
		for _,c := range location.Locations{
			if strings.HasPrefix(strings.ToLower(c),strings.ToLower(sumbit)){
				var artist models.Artist
				getArtistById(location.Id,&artist)
				matchingArtists=append(matchingArtists, artist)
			}
		}
		

		}

		if len(matchingArtists) == 0 {
			RenderSearchErrorPage(http.StatusOK, w, "Nothing")
			return
		}
	

	s := "templates/search.html"
	tmpl, err := template.ParseFiles(s)
	if err != nil {
		RenderErrorPage(http.StatusInternalServerError, w)
		return
	}

	tmpl.Execute(w, matchingArtists)
}

func ServeStatic(w http.ResponseWriter, r *http.Request) {
	println(r.URL.Path)
	path := strings.TrimPrefix(r.URL.Path, "/static/")

	if path != "" {
		http.ServeFile(w, r, "./static/"+path)
	} else {
		w.WriteHeader(http.StatusNotFound)
		return
	}
}

func RenderErrorPage(errorCode int, w http.ResponseWriter) {
	tmpl, err := template.ParseFiles("templates/error.html")

	if err != nil {
		w.WriteHeader(errorCode)
		tmpl.Execute(w, ErrorMsgMap[http.StatusInternalServerError])
		return
	}

	w.WriteHeader(errorCode)
	tmpl.Execute(w, ErrorMsgMap[errorCode])
}

func TrimSpaces(input string) string {
	return strings.TrimSpace(input)
}

func RenderSearchErrorPage(statusCode int, w http.ResponseWriter, message string) {
	w.WriteHeader(statusCode)

	errorPage := `<!DOCTYPE html>
	<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="stylesheet" href="../static/error.css">

		<link rel="apple-touch-icon" sizes="180x180" href="../static/favicons/apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="32x32" href="../static/favicons/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="../static/favicons/favicon-16x16.png">
		<link rel="manifest" href="../static/site.webmanifest">
		
		<title> {{ .Msg }}</title>
	</head>
	<body>
		
		<h2>{{ .Msg }}</h2>
	</body>
	</html>`

	tmpl, err := template.New("errorPage").Parse(errorPage)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	data := struct {
		
		Msg  string
	}{
		
		Msg:  message,
	}

	err = tmpl.Execute(w, data)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                